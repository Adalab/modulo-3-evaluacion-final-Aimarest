{"ast":null,"code":"var _jsxFileName = \"/home/adalaber/Adalab/modulo-3/Evaluacion final-Modulo-3-React/modulo-3-evaluacion-final-Aimarest/src/components/App.js\",\n    _s = $RefreshSig$();\n\nimport \"../styles/App.scss\";\nimport { useState, useEffect } from \"react\";\nimport { Routes, Route } from \"react-router-dom\";\nimport getApiMovies from \"../services/MoviesApi\";\nimport objectToExport from \"../services/LocalStorage\";\nimport Header from \"./Header\";\nimport Filters from \"./Filters\";\nimport Footer from \"./Footer\";\nimport MovieSceneList from \"./MovieSceneList\";\nimport MovieSceneDetail from \"./MovieSceneDetail\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\n\nfunction App() {\n  _s();\n\n  //Buscar en localStorage el valor del input del filtro.\n  const inputText = objectToExport.get(\"inputText\", \"\"); //Busco en el LS lo que hay guardado con la key \"movies\", y si no hay nada, me retorna un array vacío (defaultValue):\n\n  const [movieScenes, setMovieScenes] = useState(objectToExport.get(\"movies\", [])); //Buscamos en el ls el valor del select del año.\n\n  const yearSearch = objectToExport.get(\"yearSearch\", \"\"); //Variables de estado para los input de búsqueda:\n\n  const [filterYear, setFilterYear] = useState(yearSearch);\n  const [filterName, setFilterName] = useState(inputText); // Usamos un useEffect para ejecutar el fetch() una sóla vez al cargar la página.\n\n  useEffect(() => {\n    if (movieScenes.length === 0) {\n      getApiMovies().then(data => {\n        data = data.map((scene, index) => ({ ...scene,\n          id: index\n        })); //Guardo en el ls lo que me ha devuelto el fetch\n\n        objectToExport.set(\"movies\", data); //Modifico la variable de estado del array de películas.\n\n        setMovieScenes(data);\n      });\n    }\n\n    return () => {\n      objectToExport.set(\"movies\", []); //Si no está vacío el LS, sustituya lo que hay por un array vacío.\n    };\n  }, []); //Función que recorre el array de escenas para agrupar los años de las películas en un array:\n\n  const getYears = () => {\n    const yearMovies = movieScenes.map(movie => movie.year); // Función que ordena los años de menor a mayor y filtra para que ningún año se repita :\n\n    const uniqueYear = yearMovies.sort((a, b) => a - b).filter((movie, i) => {\n      return yearMovies.indexOf(movie) === i; //indexOf devuelve el primer indice en el que se puede encontrar un elemento.Cuando el índice del elemento que se está recorriendo en ese momento no sea igual que el primer índice de ese elemento,no lo incluye en el nuevo array.\n    });\n    return uniqueYear;\n  }; //Filtro por año:\n\n\n  const filterByYear = value => {\n    setFilterYear(value);\n    objectToExport.set(\"yearSearch\", value);\n  }; //Fitro por nombre:\n\n\n  const filterByName = value => {\n    setFilterName(value);\n    objectToExport.set(\"inputText\", value);\n  }; //Ordenar las películas por orden alfabético y filtrado:\n\n\n  const movieFilters = movieScenes.sort((a, b) => a.name > b.name ? 1 : a.name < b.name ? -1 : 0) //Si el value del select del año es \"\", significa que queremos all scenes, con lo cual devuelve todas.Si no está en \"\", significa que la usuaria ha seleccionado un año, y me devuelve las escenas en las que el año sea igual que el año seleccionado.\n  .filter(movie => {\n    return filterYear === \"\" ? true : movie.year === parseInt(filterYear); //Tengo que hacer el parseInt porque el movie.year es un string y el filterYear es un número.\n  }).filter(movie => {\n    if (filterName.length === 0) {\n      //Significa que la usuaria no ha escrito nada en el input y me devuelve el array completo de escenas\n      return true;\n    } else {\n      //Significa que la usuaria ha escrito algo, y me va a devolver un array de escenas cuyo nombre incluya lo que ha escrito la usuaria. Todo pasado a minusculas para que de igual como lo escriba.\n      if (movie.name.toLowerCase().includes(filterName.toLowerCase())) {\n        return true;\n      }\n    }\n\n    return false;\n  });\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    children: [/*#__PURE__*/_jsxDEV(Header, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 94,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"main\", {\n      children: /*#__PURE__*/_jsxDEV(\"section\", {\n        children: /*#__PURE__*/_jsxDEV(Routes, {\n          children: [/*#__PURE__*/_jsxDEV(Route, {\n            path: \"/\",\n            element: /*#__PURE__*/_jsxDEV(_Fragment, {\n              children: [/*#__PURE__*/_jsxDEV(Filters, {\n                filterName: filterName,\n                years: getYears(),\n                filterYear: filterYear,\n                filterByYear: filterByYear,\n                setFilterYear: setFilterYear,\n                filterByName: filterByName,\n                setFilterName: setFilterName\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 102,\n                columnNumber: 19\n              }, this), /*#__PURE__*/_jsxDEV(MovieSceneList, {\n                movies: movieFilters\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 111,\n                columnNumber: 19\n              }, this)]\n            }, void 0, true)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 98,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(Route, {\n            path: \"/movie/:movieIndex\",\n            element: /*#__PURE__*/_jsxDEV(MovieSceneDetail, {}, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 115,\n              columnNumber: 55\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 115,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 97,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 96,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 95,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Footer, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 119,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 93,\n    columnNumber: 5\n  }, this);\n}\n\n_s(App, \"w6tX2hFdV25101wnUfqjaLhz6+Y=\");\n\n_c = App;\nexport default App;\n\nvar _c;\n\n$RefreshReg$(_c, \"App\");","map":{"version":3,"sources":["/home/adalaber/Adalab/modulo-3/Evaluacion final-Modulo-3-React/modulo-3-evaluacion-final-Aimarest/src/components/App.js"],"names":["useState","useEffect","Routes","Route","getApiMovies","objectToExport","Header","Filters","Footer","MovieSceneList","MovieSceneDetail","App","inputText","get","movieScenes","setMovieScenes","yearSearch","filterYear","setFilterYear","filterName","setFilterName","length","then","data","map","scene","index","id","set","getYears","yearMovies","movie","year","uniqueYear","sort","a","b","filter","i","indexOf","filterByYear","value","filterByName","movieFilters","name","parseInt","toLowerCase","includes"],"mappings":"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","sourcesContent":["import \"../styles/App.scss\";\nimport { useState, useEffect } from \"react\";\nimport { Routes, Route } from \"react-router-dom\";\nimport getApiMovies from \"../services/MoviesApi\";\nimport objectToExport from \"../services/LocalStorage\";\nimport Header from \"./Header\";\nimport Filters from \"./Filters\";\nimport Footer from \"./Footer\";\nimport MovieSceneList from \"./MovieSceneList\";\nimport MovieSceneDetail from \"./MovieSceneDetail\";\n\nfunction App() {\n  //Buscar en localStorage el valor del input del filtro.\n  const inputText = objectToExport.get(\"inputText\", \"\");\n  //Busco en el LS lo que hay guardado con la key \"movies\", y si no hay nada, me retorna un array vacío (defaultValue):\n  const [movieScenes, setMovieScenes] = useState(\n    objectToExport.get(\"movies\", [])\n  );\n  //Buscamos en el ls el valor del select del año.\n  const yearSearch = objectToExport.get(\"yearSearch\", \"\");\n  //Variables de estado para los input de búsqueda:\n  const [filterYear, setFilterYear] = useState(yearSearch);\n  const [filterName, setFilterName] = useState(inputText);\n\n  // Usamos un useEffect para ejecutar el fetch() una sóla vez al cargar la página.\n\n  useEffect(() => {\n    if (movieScenes.length === 0) {\n      getApiMovies().then((data) => {\n        data = data.map((scene, index) => ({\n          ...scene,\n          id: index,\n        }));\n        //Guardo en el ls lo que me ha devuelto el fetch\n        objectToExport.set(\"movies\", data);\n        //Modifico la variable de estado del array de películas.\n        setMovieScenes(data);\n      });\n    }\n    return () => {\n      objectToExport.set(\"movies\", []); //Si no está vacío el LS, sustituya lo que hay por un array vacío.\n    };\n  }, []);\n\n  //Función que recorre el array de escenas para agrupar los años de las películas en un array:\n  const getYears = () => {\n    const yearMovies = movieScenes.map((movie) => movie.year);\n\n    // Función que ordena los años de menor a mayor y filtra para que ningún año se repita :\n\n    const uniqueYear = yearMovies\n      .sort((a, b) => a - b)\n      .filter((movie, i) => {\n        return yearMovies.indexOf(movie) === i; //indexOf devuelve el primer indice en el que se puede encontrar un elemento.Cuando el índice del elemento que se está recorriendo en ese momento no sea igual que el primer índice de ese elemento,no lo incluye en el nuevo array.\n      });\n\n    return uniqueYear;\n  };\n\n  //Filtro por año:\n\n  const filterByYear = (value) => {\n    setFilterYear(value);\n    objectToExport.set(\"yearSearch\", value);\n  };\n\n  //Fitro por nombre:\n  const filterByName = (value) => {\n    setFilterName(value);\n    objectToExport.set(\"inputText\", value);\n  };\n  //Ordenar las películas por orden alfabético y filtrado:\n\n  const movieFilters = movieScenes\n    .sort((a, b) => (a.name > b.name ? 1 : a.name < b.name ? -1 : 0))\n    //Si el value del select del año es \"\", significa que queremos all scenes, con lo cual devuelve todas.Si no está en \"\", significa que la usuaria ha seleccionado un año, y me devuelve las escenas en las que el año sea igual que el año seleccionado.\n    .filter((movie) => {\n      return filterYear === \"\" ? true : movie.year === parseInt(filterYear); //Tengo que hacer el parseInt porque el movie.year es un string y el filterYear es un número.\n    })\n    .filter((movie) => {\n      if (filterName.length === 0) {\n        //Significa que la usuaria no ha escrito nada en el input y me devuelve el array completo de escenas\n        return true;\n      } else {\n        //Significa que la usuaria ha escrito algo, y me va a devolver un array de escenas cuyo nombre incluya lo que ha escrito la usuaria. Todo pasado a minusculas para que de igual como lo escriba.\n        if (movie.name.toLowerCase().includes(filterName.toLowerCase())) {\n          return true;\n        }\n      }\n      return false;\n    });\n  return (\n    <div className=\"App\">\n      <Header />\n      <main>\n        <section>\n          <Routes>\n            <Route\n              path=\"/\"\n              element={\n                <>\n                  <Filters\n                    filterName={filterName}\n                    years={getYears()}\n                    filterYear={filterYear}\n                    filterByYear={filterByYear}\n                    setFilterYear={setFilterYear}\n                    filterByName={filterByName}\n                    setFilterName={setFilterName}\n                  />\n                  <MovieSceneList movies={movieFilters} />\n                </>\n              }\n            />\n            <Route path=\"/movie/:movieIndex\" element={<MovieSceneDetail />} />\n          </Routes>\n        </section>\n      </main>\n      <Footer />\n    </div>\n  );\n}\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}